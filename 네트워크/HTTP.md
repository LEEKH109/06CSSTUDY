# 1. HTTP / 1.0

HTTP/1.0은 기본적으로 한 열결당 하나의 요청을 처리. 
이는 RTT의 증가를 불러오게 되었다. 

<img width="575" alt="스크린샷 2023-08-22 오후 8 30 31" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/709379ea-aa79-4398-8414-daf1bc5ea234">

* 단점
  
  서버로부터 파일을 가져올 때마다 TCP의 3 웨이 핸드쉐이크를 계속해서 열어야 하기 때문에 'RTT가 증가'.  

  > RTT : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간. 패킷 왕복 시간

* RTT의 증가를 해결하기 위한 방법
  
  - 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩
--- 
### 1. 이미지 스플리팅
   
많은 이미지를 다운받으면 과부하 발생. 

많은 이미지가 합쳐 있는 하나의 이미지를 다운받고 이를 기반으로 Background-image의 position을 이용하여 이미지를 표기하는 방법.

### 2. 코드 압축
   
코드를 압축해서 개행문자, 빈칸을 없애 코드의 크기를 최소화하는 방법.

### 3. 이미지 Base64 인코딩
   
이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법.

> 인코딩 : 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식 
---
---
# 2. HTTP / 1.1 

HTTP/1.0에서 발전한 것이 HTTP/1.1. 

매번 TCP 연결을 하는 것이 아니라 한번 TCP 초기화를 한 이후에 keep-alive라는 옵션으로 여러개의 파일을 송수신. 

한번 TCP 3웨이 핸드셰이크가 발생하면 그 다음부터 발생하지 않는다. 

그러나 문서에 포함된 다수의 리소스를 처리하려면 요청할 리소수 개수에 비례해서 대기시간이 길어진다는 단점이 있다. 



* TCP 3 웨이 핸드셰이크
  
<img width="627" alt="스크린샷 2023-08-22 오후 8 44 03" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/1ee214e2-fa86-4b6e-845c-d708f95ba34f">

### [STEP 1]

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 된다.

### [STEP 2] 

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송.

A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.

### [STEP 3]

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 된다. 

이때의 B서버 상태가 ESTABLISHED.

위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식.

> HOL Blocking
>  : 네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상.
  
---
---
# 3. HTTP / 2

HTTP /2 는 SPDY 프로토콜에서 파생된 HTTP/1.x보다 지연시간을 줄이고 응답시간을 더 빠르게 할 수 있다.

멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜. 

### 멀티플렉싱

여러개의 스트림을 사용하여 송수신. 
> 스트림 : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름

* 정의 

  하나의 통신채널을 통해 둘 이상의 데이터(시그널)를 전송하는 데 사용되는 기술

  물리적 장치의 효율을 위해 최소한의 물리적 장치로 최대한의 데이터를 전달하는 기술

<img width="491" alt="스크린샷 2023-08-22 오후 8 50 51" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/438182e0-3f8f-47ec-b732-5cbc28fe9014">

그림 1과 같이 서버라는 하나의 프로세스에서 시그널을 통해 3개의 클라이언트와 모두 데이터를 주고받는 것을 볼 수 있다.

### 헤더 압축

HTTP/1.x는 크기가 큰 헤더라는 문제가 있었다.

이를 HTTP/2에서는 헤더 압축을 써서 해결한다. 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가진다.

### 서버 푸시 

HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었다면,
HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있다.

<img width="661" alt="스크린샷 2023-08-22 오후 8 55 52" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/4732a6c2-e68b-478d-a5bf-9ed1a53acd79">

html을 읽으면서 그 안에 들어있던 css파일을 서버에 푸시하여 클라이언트에 먼저 줄 수 있다.

---
---
# 4. HTTPS 

HTTP/2는 HTTPS 위에서 동작한다. 

애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TTS 계층을 넣은 신뢰할 수 있는 HTTP 요청.

이를 통해 통신을 암호화.

## SSL/TTS

<img width="637" alt="스크린샷 2023-08-22 오후 10 10 55" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/1b5b2c63-de32-4094-92d0-a5059132337c">

* 전송 계층에서 보안을 제공하는 프로토콜.

* 클라이언트가 서버가 통신할 때 SSL/TTS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 한다.

* 보안 세션을 기반으로 데이터를 암호화한다. 

* 보안 세션이 만들어질 떄 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다.

### SSL/TTS 작동법
  
* SSL은 높은 수준의 개인정보 보호를 제공하기 위해, 웹에서 전송되는 데이터를 암호화한다. 따라서, 데이터를 가로채려는 자는 거의 해독할 수 없는 복잡한 문자만 보게 된다.

* SSL은 두 통신 장치 사이에 핸드셰이크라는 인증 프로세스를 시작하여 두 장치의 ID를 확인한다.

* SSL은 또한 데이터 무결성을 제공하기 위해 데이터에 디지털 서명하여 데이터가 의도된 수신자에 도착하기 전에 조작되지 않았다는 것을 확인한다. 

  > 데이터 무결성: 데이터의 Lifecycle 동안 모든 데이터가 얼마나 완전하고, 일관되며, 정확한지를 나타내는 정도.

### 보안세션
  
  보안이 시작되고 끝나는 동안 유지되는 세션.
  
### TLS의 핸드셰이크
  
클라이언트와 서버와 키를 공유하고 이를 기반으로 인증, 인증 확인 등의 작업이 일어나는 단 한번의 1-RTT가 생긴 후 데이터를 송수신한다.

<img width="756" alt="스크린샷 2023-08-22 오후 9 36 16" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/82e69cbd-4092-4afe-84fb-100767bf867d">

TLS는 안전한 인터넷 통신을 위한 암호화 및 인증 프로토콜. 

TLS 핸드셰이크는 TLS 암호화를 사용하는 통신 세션을 실행하는 프로세스. 

TLS 핸드셰이크 중에, 통신하는 양측에서는 메시지를 교환하여 서로를 인식하고 서로를 검증하며 사용할 암호화 알고리즘을 구성하고 세션 키에 합의한다. 

TLS 핸드셰이크는 HTTPS 작동 원리의 근간을 이룬다.

### TLS 과정

1. 클라에서 서버로 사이퍼 슈트(cypher suites)를 서버에 전달
2. 서버는 받은 사이퍼슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인
3. 제공할 수 있다면 서버 -> 클라이언트로 인증서를 보내는 인증 메커니즘 시작
4. 해싱 알고리즘 등으로 암호화된 데이터를 송수신 시작
   
- 사이퍼 슈트
  
  프로토콜, AEAD 사이퍼모드, 해싱 알고리즘이 나열된 규약

- AEAD 사이퍼 모드
  
  데이터 암호화 알고리즘
  AES_128_GCM -> 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM이 결합된 알고리즘

- 인증 메커니즘
  
  CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어진다.
  발급한 인증서는 안전한 연결을 시작하는데 있어 필요한 공개키를 클라에 제공, 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장.
  인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어진다.

- CA 발급과정
  
  자신의 서비스가 CA를 인증서를 발급받으려면 자신의 사이트 정보와 공개키를 CA에 제출해야한다.
  CA는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀키 등을 기반으로 CA 인증서 발급.

* 개인키
  
  비밀키라고도 하며, 개인이 소유하고 있는 키(반드시 자신만 소유해야하는 키)

* 공개키
  
  공개되어 있는 키

### 암호화 알고리즘

- 디피-헬만 키 교환 알고리즘 : 암호키를 교환하는 하나의 방법
- 상대방의 공개키와 나의 개인키를 이용하여 계산을 하면 비밀키가 나온다.
- 나와 상대방은 비밀키를 사용하여 데이터를 암호화한 후 전달.
- 이러한 DH 알고리즘은 "키 교환(key exchange)" 알고리즘으로 대칭키를 공유하는데 사용.

  y= g^x mod p

  - 공개 값 공유, 각자의 비밀 값과 혼합 후 혼합 값 공유
  - 각자의 비밀 값과 또 혼합
  - 공통의 암호키 생성

### 해싱 알고리즘

- 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
- 해시: 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값
- 해싱: 임의의 데이터를 해시로 바꿔주는 일
- 해시 함수: 임의의 데이터를 입력으로 일정한 길이의 데이터를 바꿔주는 함수


### HTTPS 구축방법

- 직접 CA에서 구매한 인증키를 기반으로 서비스 구축
- 서버 앞단의 HTTPS를 제공하는 로드밸런서를 둠
- 서버 앞단에 HTTPS를 제공하는 CDN을 둬서 구축

---
---

# 5. HTTP/3

QUIC라는 계층 위에서 돌아감. TCP 기반이 아닌 UDP 기반.

멀티 플렉싱을 가지고 있으며 초기 연결 설정시 지연 시간 감소라는 장점이 있다. 

<img width="735" alt="스크린샷 2023-08-22 오후 9 44 03" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/2058b8d0-41a0-45b3-90f7-08601bd32258">

첫 연결 설정에 1-RTT 소요.

QUIC는 순방향 오류 수정 메커니즘이 적용된다.

전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식.

