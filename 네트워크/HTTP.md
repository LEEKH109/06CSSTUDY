### 목차 

1. HTTP/1.0
2. HTTP/1.1
3. HTTP/2
4. HTTPS
5. HTTP/3


### 1. HTTP/1.0

HTTP/1.0은 기본적으로 한 열결당 하나의 요청을 처리하도록 설계되었다. 
이는 RTT의 증가를 불러오게 되었다. 

<img width="575" alt="스크린샷 2023-08-22 오후 8 30 31" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/709379ea-aa79-4398-8414-daf1bc5ea234">

서버로부터 파일을 가져올 때마다 TCP의 3 웨이 핸드쉐이크를 계속해서 열어야 하기 때문에 RTT가 증가하는 단점이 있다. 

* RTT : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간. 패킷 왕복 시간

* RTT의 증가를 해결하기 위한 방법
  - 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩
 
1. 이미지 스플리팅
많은 이미지를 다운받으면 과부하가 걸린다. 많은 이미지가 합쳐 있는 하나의 이미지를 다운받고 이를 기반으로 Background-image의 position을 이용하여 이미지를 표기하는 방법

2. 코드 압축
코드를 압축해서 개행문자, 빈칸을 없애 코드의 크기를 최소화하는 방법

3. 이미지 Base64 인코딩
이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법.

* 인코딩 : 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해 다른 형태나 형식으로 변환하는 처리 방식 

---
### 2. HTTP / 1.1 
HTTP/1.0에서 발전한 것이 HTTP/1.1이다. 
매번 TCP 연결을 하는 것이 아니라 한번 TCP 초기화를 한 이후에 keep-alive라는 옵션으로 여러개의 파일을 송수신할 수 있게 바뀌었다. 
한번 TCP 3웨이 핸드셰이크가 발생하면 그 다음부터 발생하지 않는다. 그러나 문서에 포함된 다수의 리소스를 처리하려면 요청할 리소수 개수에 비례해서 대기시간이 길어진다는 단점이 있다. 

* TCP 3 웨이 핸드셰이크
<img width="627" alt="스크린샷 2023-08-22 오후 8 44 03" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/1ee214e2-fa86-4b6e-845c-d708f95ba34f">

[STEP 1]

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 되는 것이다.

[STEP 2] 

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.

[STEP 3]

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.
위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.

* HOL Blocking

네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상. 

---
### HTTP / 2
HTTP /2 는 SPDY 프로토콜에서 파생된 HTTP/1.x보다 지연시간을 줄이고 응답시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜이다. 

* 멀티플렉싱
여러개의 스트림을 사용하여 송수신한다는 것이다. (스트림 : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름)
"하나의 통신채널을 통해 둘 이상의 데이터(시그널)를 전송하는 데 사용되는 기술"
"물리적 장치의 효율을 위해 최소한의 물리적 장치로 최대한의 데이터를 전달하는 기술"

<img width="491" alt="스크린샷 2023-08-22 오후 8 50 51" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/438182e0-3f8f-47ec-b732-5cbc28fe9014">

그림 1과 같이 서버라는 하나의 프로세스에서 시그널을 통해 3개의 클라이언트와 모두 데이터를 주고받는 것을 볼 수 있다.

* 헤더 압축
HTTP/1.x는 크기가 큰 헤더라는 문제가 있었다.
이를 HTTP/2에서는 헤더 압축을 써서 해결한다. 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가진다.

* 서버 푸시 
HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었다면,
HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있다.

<img width="661" alt="스크린샷 2023-08-22 오후 8 55 52" src="https://github.com/Youth787/06CSSTUDY/assets/90955152/4732a6c2-e68b-478d-a5bf-9ed1a53acd79">

html을 읽으면서 그 안에 들어있던 css파일을 서버에 푸시하여 클라이언트에 먼저 줄 수 있다.

---
### HTTPS 

HTTP/2는 HTTPS 위에서 동작한다. 
애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TTL 계층을 넣은 신뢰할 수 있는 HTTP 요청.
이를 통해 통신을 암호화.

* SSL/TTS






